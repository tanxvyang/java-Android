	布局Layout
	线性布局LinearLayout
		可以在一个方向上(水平或垂直)顺序排放元素
	相对布局 RealativeLayout
		允许元素指定相对于其他元素排放位置
	绝对布局AbsoluteLayout

	帧布局AbsoulteLayout
	      每个元素认为是一个帧,这些帧会根据定义gravity属性自动对齐
	 表格布局TableLayout
	      其实就是线性布局,在线下布局基础上做表格
	  网格布局gridlayout




  layout_width
         宽
  
  match_parent填充父元素

   layout_height
   高
   
   wrap_content自适应


   orientation 摆放方向(默认垂直)
         vertical垂直

        horizontal水平


   text 文本

   hint  
      edittest//只是显示可见的文本

  layout_below   每个元素的下方
  layout_above   某个元素的上方
  layout_toLeftOF




  rowCount  //行
  columnCount//列





--------------------------------------------------

单位
   dp
   sp

 属性
    layout_marging


布局Layout
	线性布局 LinearLayout
		可以在一个方向上（水平或垂直）顺序排放元素

	相对布局 RelativeLayout
		允许元素指定相对于其他元素排放位置

	绝对布局 AbsoluteLayout
		允许元素指定x和y的坐标

	帧布局	 FrameLayout
		每个元素认为是一个帧，这些帧会根据定义gravity属性自动对齐

	表格布局 TableLayout
		其实就是线性布局，在线性布局基础上做表格

	网格布局 GridLayout
		在Android4.0版本之后存在，跟表格布局差不多


属性
	id
		元素的唯一标识

	layout_width
		宽
			match_parent
				填充父元素

			wrap_content
				自适应，元素有多大就多大

	layout_height
		高
			match_parent
				填充父元素

			wrap_content
				自适应，元素有多大就多大

	orientation
		摆放方式 （默认垂直）
			vertical
				垂直

			horizontal
				水平

	text
		文本

	hint
		EditText中提示的文字

	layout_below		某个元素的下方
	layout_above		某个元素的上方
	layout_toLeftOf		某个元素的左边
	layout_toRightOf	某个元素的右边
	layout_alignTop		本元素的上边缘和某个元素上边缘对齐
	layout_alignLeft	本元素的左边缘和某个元素左边缘对齐
	layout_alignBottom	本元素的下边缘和某个元素下边缘对齐
	layout_alignRight	本元素的右边缘和某个元素右边缘对齐

	layout_x		x坐标
	layout_y		y坐标

	rowCount		行
	columnCount		列



	-------------10.26---------------
IO

	输入输出流
	文件
		java.io.File类是java.io包中唯一代表硬盘文件本身的类
		提供了对文件(不包括内容)或者目录的操作

流
	stream使用与IO编程的抽象概念
	表示线性的,顺序的输入或输出
	数据通信的管道

	顶层类型
	        输入流
			从外部流入

			字节流:  InputStream
			字符流:  Reader

		输出流 
			流入外部

			字节流:  OutputStream
			字符流:  Writer
	
	分类
		方向
			输入流
			输出流
		类型
			
			字节流
			字符流

		功能
			节点流

			包装流
字节的节点流
	FileInputStream       FileOutputStream  (硬盘)

	ByteArrayInputStream  ByteArrayOutputStream  (内存)

	System.in(键盘)       System.out(控制台)
	......
字符节点流(文件乱码,不用)
	FileReader		FileWriter 
	CharArrayReader		CharArrayReaderWriter
	StringReader	        StringWriter
--------------------11.1------------------------------------------------------------
包装流
   桥梁流
	InputStreamReader	       outputStreamWrilt

   带缓冲区流
		BufferedReader			PrintWriter
		写入数据什么情况会真的将数据写入文件?
		  1.缓冲区内存满了
		  2.关闭流时
		  3.调用flush方法时
对象流
	
	对象序列化

	objectinputstream              objectoutputstream

	对象序列化的类型的实现Serializale接口

	transient关键字
				对象序列化时不序列化这个实行


对一个文件同时进行操作
	RandomAccessFile









	-----------------------------1108文件权限-----------------
	r 读
	w 写
	x 可执行
	

	- 文件
	d 目录
	l 软链接

	所有者 同组人 其他人

文件r	读文件
    w	写文件
    x	可执行文件

目录r	查看目录的内容
    w	可以在这个目录中创建、删除文件或目录
    x	进入目录

0				-rw-rw----
MODE_WORLD_READABLE		-rw-rw-r--
MODE_WORLD_WRITEABLE		-rw-rw--w-

修改权限
	abd shell

	chmod 权限 文件/目录

	--------------------SQLite_1109-------------------
SQLite 
	android 中内置的数据库
	使用
		1.创建一个类继承SQLiteOpenHeleper

		2.实现onCreate和onUpcrete方法
			oncreate只会在使用Helper对象被调用时
进入数据库
>adb shell
vbox86p:/ # cd /data/data
vbox86p:/data/data # ls
vbox86p:/data/data # cd com.example.mrtan.databases
vbox86p:/data/data/com.example.mrtan.databases # cd databases
vbox86p:/data/data/com.example.mrtan.databases/databases # ls


---------------电话簿-------------
页面一
添加联系人
查看所有联系人


页面二

姓名
电话
添加电话
返回


页面三

回到首页

1 姓名: 电话:

1 姓名: 电话:

1 姓名: 电话:









-------------------listView --11.15---------

<ListView android:id="@+id/lv"
			android:layout_width="match_parent" 
			  android:layout_height="match_parent"
			  android:fastScrollEnabled="true">
		
		
	</ListView>


	android:fastScrollEnabled="true"//滚动条

	//显示数据与 其控件有区别  数据来源于适配器
	lv.setAdapter(new MyListAdapter());


prvate class MyListAdapter extends BaseAdapter{
//  getCount 一共显示多少条数据

//getItem  返回指定position 位置的对应对象

//getview 获得一个view 用来显示ListView的数据
}





------------------1121---------------------
InputType


 android:visibility="gone"


 ---------------------------------------------

 SmsManger


---------------------------1128---C:\Users\MR。tan\Documents\GitHub\java-Android\coreajava\src\jdbc\testJDBC_1128\TestTheadA.java------

多线程
		并发
			同时执行多个程序或一个程序中执行多段代码
		时间片
			在操作系统中使用时间片机制来实现并发运算
			因为一个计算机(CPU单核情况),在最小时间单位上,只能执行一个程序的运算,他控制多个程序的多个任务
			交替运行,达到并发运行的效果
	         	多核cpu才能实现正真的并发
		 
	 进程
		在操作系统中,运行的每一个程序是一个进程
		
		
		线程
			在一个程序中运行的每一段代码是一个线程

	实现多线程
				实现Runnable接口,实现run方法

				继承Thread类,重写run方法

	一个Thread对象就是一个线程


启动线程
		调用start()方法
		自己调用run()方法不会启动线程


Thread 和Runnable 方法的优缺点
		Thread简单,方便,易开发

		使用runnable接口,可以自由继承另一个类
		   同一个runnable对象可以传递给多个线程使用
		   资源共享
		   减少创建线程实例所需要的时间


网络

生产者和消费者

